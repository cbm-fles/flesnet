
Three components:
- stsender
- tsbuilder
- tssched

# Draft protocol

stsender (connect) <-> tssched (listen)
----------------------

-> REGISTER
     hostname, pid
<- OK

-> ANNOUNCE_SUBTIMESLICE
     id, size
<- OK

-> RETRACT_SUBTIMESLICE
     id, size

<- RELEASE_SUBTIMESLICE
     id
-> OK

-> UNREGISTER
<- OK

(What happens if one of the partners stops unexpectedly?
Should we do heartbeating?)


tsbuilder (connect) <-> stsender (listen)
----------------------

-> REQUEST_SUBTIMESLICE
    timeslice id

<- SEND_SUBTIMESLICE
    return status
    serialized descriptor, timeslice data (optional)


tsbuilder <-> tssched (TO BE UPDATED!)
---------------------

-> REGISTER
     hostname, pid
<- OK

-> MEMORY_AVAILABLE
     size
<- OK

<- NEW_TIMESLICE
     serialized descriptor
-> OK

-> RELEASE_TIMESLICE / FAILED_TIMESLICE(?)
     timeslice id
     success state
<- OK

-> UNREGISTER
<- OK




--------------------------------------

support for partitions!



stsender implementation
-----------------------

send REGISTER to tssched
connect to subtimeslice item distributor (tsc_server)
wait for message on either interface:
  tsc_server:
    WORK_iTEM -> 

... maybe integrate? seems awfully redundant otherwise...

--------------------------------------

# WORK PLAN

DONE - Merge dev_ucx into tsc_server branch
- Update app/tsc_server:
  - Make dependent on ucx
  - Put app logic from Application into new class (stbuilder)
  - Create new class (stsender) with its own thread
  - Start with internal interface, remove shm_ipc interface
  - Implement UCX connections (listener for tsbuilders, initiate connection to tssched)
  - Create new st descriptor class for transmission
  